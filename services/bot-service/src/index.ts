// ===== services/bot-service/src/index.ts =====
import TelegramBot from 'node-telegram-bot-api';
import express from 'express';
import axios from 'axios';
import dotenv from 'dotenv';
import { format } from 'date-fns';

dotenv.config();

const app = express();
app.use(express.json());

const PORT = process.env.BOT_SERVICE_PORT || 3001;
const TELEGRAM_BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN!;
const NLP_SERVICE_URL = process.env.NLP_SERVICE_URL || 'http://nlp-service:3002';
const REMINDER_SERVICE_URL = process.env.REMINDER_SERVICE_URL || 'http://reminder-service:3003';

// Kh·ªüi t·∫°o bot
const bot = new TelegramBot(TELEGRAM_BOT_TOKEN, { polling: true });

// Command parser
const parseCommand = (text: string) => {
  const parts = text.split(' ');
  const command = parts[0].toLowerCase();
  const args = parts.slice(1);
  return { command, args, fullText: text };
};

// Format task display
const formatTask = (task: any) => {
  const formattedDate = format(new Date(task.dueDate), 'HH:mm dd-MM-yyyy');
  const statusIcon = task.status === 'completed' ? '‚úÖ' : '‚è≥';
  const overdueIcon = new Date(task.dueDate) < new Date() && task.status === 'pending' ? 'üî¥' : '';
  
  return `[${task.taskId}] üìù ${task.taskContent}\nüìÖ ${formattedDate}\n${statusIcon} Tr·∫°ng th√°i: ${task.status === 'pending' ? 'Pending' : 'Done'} ${overdueIcon}`;
};

// Format task list with pagination
const formatTaskList = (data: any, title: string) => {
  if (!data.tasks || data.tasks.length === 0) {
    return `${title}:\n(Kh√¥ng c√≥ c√¥ng vi·ªác n√†o ƒë∆∞·ª£c t√¨m th·∫•y)`;
  }

  let message = `${title} (Trang ${data.pagination.currentPage}/${data.pagination.totalPages}):\n\n`;
  
  data.tasks.forEach((task: any) => {
    message += formatTask(task) + '\n\n';
  });

  if (data.pagination.totalPages > 1) {
    message += `üìÑ Trang ${data.pagination.currentPage}/${data.pagination.totalPages} - T·ªïng: ${data.pagination.total} c√¥ng vi·ªác`;
  }

  return message;
};

// Command handlers
bot.onText(/\/start/, (msg) => {
  const chatId = msg.chat.id;
  const welcomeMessage = `Xin ch√†o üëã! T√¥i l√† TaskReminder Bot.
T√¥i s·∫Ω gi√∫p b·∫°n qu·∫£n l√Ω v√† nh·∫Øc nh·ªü c√¥ng vi·ªác h·∫±ng ng√†y.
üëâ G√µ /help ƒë·ªÉ xem danh s√°ch l·ªánh.`;
  
  bot.sendMessage(chatId, welcomeMessage);
});

bot.onText(/\/help/, (msg) => {
  const chatId = msg.chat.id;
  const helpMessage = `üìå C√°c l·ªánh b·∫°n c√≥ th·ªÉ d√πng:
/add [n·ªôi dung] - Th√™m c√¥ng vi·ªác m·ªõi b·∫±ng ng√¥n ng·ªØ t·ª± nhi√™n.
/list [s·ªë trang] - Li·ªát k√™ t·∫•t c·∫£ c√¥ng vi·ªác.
/pending [s·ªë trang] - Xem c√¥ng vi·ªác ch∆∞a ho√†n th√†nh.
/done [s·ªë trang] - Xem c√¥ng vi·ªác ƒë√£ ho√†n th√†nh.
/overdue [s·ªë trang] - Xem c√¥ng vi·ªác qu√° h·∫°n.
/today - C√¥ng vi·ªác h√¥m nay.
/tomorrow - C√¥ng vi·ªác ng√†y mai.
/date [DD-MM-YYYY] - L·ªçc c√¥ng vi·ªác theo ng√†y c·ª• th·ªÉ.
/search [t·ª´ kh√≥a] - T√¨m c√¥ng vi·ªác.
/update [id] [tr∆∞·ªùng]=[gi√° tr·ªã m·ªõi] - C·∫≠p nh·∫≠t c√¥ng vi·ªác.
/complete [id] - ƒê√°nh d·∫•u ho√†n th√†nh.
/delete [id] - X√≥a c√¥ng vi·ªác.`;

  bot.sendMessage(chatId, helpMessage);
});

bot.onText(/\/add (.+)/, async (msg, match) => {
  const chatId = msg.chat.id;
  const userId = msg.from?.id.toString() || '';
  const text = match![1];

  try {
    // G·ª≠i ƒë·∫øn NLP service ƒë·ªÉ x·ª≠ l√Ω
    const nlpResponse = await axios.post(`${NLP_SERVICE_URL}/process`, {
      text,
      refDate: new Date().toISOString()
    });

    const { taskContent, dueDate } = nlpResponse.data;

    // G·ª≠i ƒë·∫øn reminder service ƒë·ªÉ t·∫°o task
    const reminderResponse = await axios.post(`${REMINDER_SERVICE_URL}/tasks`, {
      userId,
      chatId: chatId.toString(),
      taskContent,
      dueDate
    });

    const task = reminderResponse.data;
    const formattedDate = format(new Date(dueDate), 'HH:mm dd-MM-yyyy');

    const successMessage = `‚úÖ ƒê√£ th√™m task m·ªõi:
üìù ${taskContent}
üìÖ Deadline: ${formattedDate}
üîî T√¥i s·∫Ω nh·∫Øc b·∫°n tr∆∞·ªõc 30 ph√∫t v√† ƒë√∫ng gi·ªù.
(Task ID: ${task.taskId})`;

    bot.sendMessage(chatId, successMessage);
  } catch (error: any) {
    console.error('Error adding task:', error.response?.data || error.message);
    bot.sendMessage(chatId, '‚ùå C√≥ l·ªói x·∫£y ra khi th√™m c√¥ng vi·ªác. Vui l√≤ng th·ª≠ l·∫°i.');
  }
});

bot.onText(/\/list(\s+(\d+))?/, async (msg, match) => {
  const chatId = msg.chat.id;
  const userId = msg.from?.id.toString() || '';
  const page = match?.[2] || '1';

  try {
    const response = await axios.get(`${REMINDER_SERVICE_URL}/tasks/user/${userId}?page=${page}&limit=10`);
    const message = formatTaskList(response.data, 'üìã T·∫•t c·∫£ c√¥ng vi·ªác');
    bot.sendMessage(chatId, message);
  } catch (error: any) {
    console.error('Error fetching tasks:', error.response?.data || error.message);
    bot.sendMessage(chatId, '‚ùå C√≥ l·ªói x·∫£y ra khi l·∫•y danh s√°ch c√¥ng vi·ªác.');
  }
});

bot.onText(/\/pending(\s+(\d+))?/, async (msg, match) => {
  const chatId = msg.chat.id;
  const userId = msg.from?.id.toString() || '';
  const page = match?.[2] || '1';

  try {
    const response = await axios.get(`${REMINDER_SERVICE_URL}/tasks/user/${userId}?status=pending&page=${page}&limit=10`);
    const message = formatTaskList(response.data, 'üìã C√¥ng vi·ªác ch∆∞a ho√†n th√†nh');
    bot.sendMessage(chatId, message);
  } catch (error: any) {
    console.error('Error fetching pending tasks:', error.response?.data || error.message);
    bot.sendMessage(chatId, '‚ùå C√≥ l·ªói x·∫£y ra khi l·∫•y danh s√°ch c√¥ng vi·ªác ch∆∞a ho√†n th√†nh.');
  }
});

bot.onText(/\/done(\s+(\d+))?/, async (msg, match) => {
  const chatId = msg.chat.id;
  const userId = msg.from?.id.toString() || '';
  const page = match?.[2] || '1';

  try {
    const response = await axios.get(`${REMINDER_SERVICE_URL}/tasks/user/${userId}?status=completed&page=${page}&limit=10`);
    const message = formatTaskList(response.data, 'üìã C√¥ng vi·ªác ƒë√£ ho√†n th√†nh');
    bot.sendMessage(chatId, message);
  } catch (error: any) {
    console.error('Error fetching completed tasks:', error.response?.data || error.message);
    bot.sendMessage(chatId, '‚ùå C√≥ l·ªói x·∫£y ra khi l·∫•y danh s√°ch c√¥ng vi·ªác ƒë√£ ho√†n th√†nh.');
  }
});

bot.onText(/\/overdue(\s+(\d+))?/, async (msg, match) => {
  const chatId = msg.chat.id;
  const userId = msg.from?.id.toString() || '';
  const page = match?.[2] || '1';

  try {
    const response = await axios.get(`${REMINDER_SERVICE_URL}/tasks/user/${userId}?filter=overdue&page=${page}&limit=10`);
    const message = formatTaskList(response.data, 'üìã C√¥ng vi·ªác qu√° h·∫°n');
    bot.sendMessage(chatId, message);
  } catch (error: any) {
    console.error('Error fetching overdue tasks:', error.response?.data || error.message);
    bot.sendMessage(chatId, '‚ùå C√≥ l·ªói x·∫£y ra khi l·∫•y danh s√°ch c√¥ng vi·ªác qu√° h·∫°n.');
  }
});

bot.onText(/\/today/, async (msg) => {
  const chatId = msg.chat.id;
  const userId = msg.from?.id.toString() || '';

  try {
    const response = await axios.get(`${REMINDER_SERVICE_URL}/tasks/user/${userId}?filter=today`);
    const currentDate = format(new Date(), 'dd-MM-yyyy');
    const message = formatTaskList(response.data, `üìÖ C√¥ng vi·ªác h√¥m nay (${currentDate})`);
    bot.sendMessage(chatId, message);
  } catch (error: any) {
    console.error('Error fetching today tasks:', error.response?.data || error.message);
    bot.sendMessage(chatId, '‚ùå C√≥ l·ªói x·∫£y ra khi l·∫•y c√¥ng vi·ªác h√¥m nay.');
  }
});

bot.onText(/\/tomorrow/, async (msg) => {
  const chatId = msg.chat.id;
  const userId = msg.from?.id.toString() || '';

  try {
    const response = await axios.get(`${REMINDER_SERVICE_URL}/tasks/user/${userId}?filter=tomorrow`);
    const tomorrowDate = format(new Date(Date.now() + 24 * 60 * 60 * 1000), 'dd-MM-yyyy');
    const message = formatTaskList(response.data, `üìÖ C√¥ng vi·ªác ng√†y mai (${tomorrowDate})`);
    bot.sendMessage(chatId, message);
  } catch (error: any) {
    console.error('Error fetching tomorrow tasks:', error.response?.data || error.message);
    bot.sendMessage(chatId, '‚ùå C√≥ l·ªói x·∫£y ra khi l·∫•y c√¥ng vi·ªác ng√†y mai.');
  }
});

bot.onText(/\/date\s+(\d{2}-\d{2}-\d{4})/, async (msg, match) => {
  const chatId = msg.chat.id;
  const userId = msg.from?.id.toString() || '';
  const dateStr = match![1];

  try {
    // Convert DD-MM-YYYY to YYYY-MM-DD format for API
    const [day, month, year] = dateStr.split('-');
    const apiDate = `${year}-${month}-${day}`;
    
    const response = await axios.get(`${REMINDER_SERVICE_URL}/tasks/user/${userId}?date=${apiDate}`);
    const message = formatTaskList(response.data, `üìÖ C√¥ng vi·ªác ng√†y ${dateStr}`);
    bot.sendMessage(chatId, message);
  } catch (error: any) {
    console.error('Error fetching tasks by date:', error.response?.data || error.message);
    bot.sendMessage(chatId, '‚ùå C√≥ l·ªói x·∫£y ra khi l·∫•y c√¥ng vi·ªác theo ng√†y. ƒê·ªãnh d·∫°ng: /date DD-MM-YYYY');
  }
});

bot.onText(/\/search (.+)/, async (msg, match) => {
  const chatId = msg.chat.id;
  const userId = msg.from?.id.toString() || '';
  const keyword = match![1];

  try {
    const response = await axios.get(`${REMINDER_SERVICE_URL}/tasks/user/${userId}?search=${encodeURIComponent(keyword)}`);
    const message = formatTaskList(response.data, `üîç K·∫øt qu·∫£ t√¨m ki·∫øm cho "${keyword}"`);
    bot.sendMessage(chatId, message);
  } catch (error: any) {
    console.error('Error searching tasks:', error.response?.data || error.message);
    bot.sendMessage(chatId, '‚ùå C√≥ l·ªói x·∫£y ra khi t√¨m ki·∫øm c√¥ng vi·ªác.');
  }
});

bot.onText(/\/update\s+(\d+)\s+(\w+)=(.+)/, async (msg, match) => {
  const chatId = msg.chat.id;
  const userId = msg.from?.id.toString() || '';
  const taskId = match![1];
  const field = match![2];
  const value = match![3];

  try {
    const response = await axios.patch(`${REMINDER_SERVICE_URL}/tasks/${taskId}`, {
      userId,
      field,
      value
    });

    let successMessage = '';
    if (field === 'content') {
      successMessage = `üîÑ Task [${taskId}] ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t n·ªôi dung:\nüìù ${value}`;
    } else if (field === 'deadline') {
      const formattedDate = format(new Date(value), 'HH:mm dd-MM-yyyy');
      successMessage = `üîÑ Task [${taskId}] ƒë√£ ƒë∆∞·ª£c c·∫≠p nh·∫≠t deadline:\nüìÖ ${formattedDate}`;
    }

    bot.sendMessage(chatId, successMessage);
  } catch (error: any) {
    console.error('Error updating task:', error.response?.data || error.message);
    if (error.response?.status === 404) {
      bot.sendMessage(chatId, `‚ùå Kh√¥ng t√¨m th·∫•y task v·ªõi ID ${taskId}.`);
    } else {
      bot.sendMessage(chatId, '‚ùå C√≥ l·ªói x·∫£y ra khi c·∫≠p nh·∫≠t c√¥ng vi·ªác.');
    }
  }
});

bot.onText(/\/complete\s+(\d+)/, async (msg, match) => {
  const chatId = msg.chat.id;
  const userId = msg.from?.id.toString() || '';
  const taskId = match![1];

  try {
    const response = await axios.patch(`${REMINDER_SERVICE_URL}/tasks/${taskId}`, {
      userId,
      field: 'status',
      value: 'completed'
    });

    const task = response.data;
    bot.sendMessage(chatId, `üéâ Task [${taskId}] "${task.taskContent}" ƒë√£ ƒë∆∞·ª£c ƒë√°nh d·∫•u l√† DONE.`);
  } catch (error: any) {
    console.error('Error completing task:', error.response?.data || error.message);
    if (error.response?.status === 404) {
      bot.sendMessage(chatId, `‚ùå Kh√¥ng t√¨m th·∫•y task v·ªõi ID ${taskId}.`);
    } else {
      bot.sendMessage(chatId, '‚ùå C√≥ l·ªói x·∫£y ra khi ƒë√°nh d·∫•u ho√†n th√†nh c√¥ng vi·ªác.');
    }
  }
});

bot.onText(/\/delete\s+(\d+)/, async (msg, match) => {
  const chatId = msg.chat.id;
  const userId = msg.from?.id.toString() || '';
  const taskId = match![1];

  try {
    const response = await axios.delete(`${REMINDER_SERVICE_URL}/tasks/${taskId}?userId=${userId}`);
    const task = response.data.task;
    bot.sendMessage(chatId, `üóëÔ∏è Task [${taskId}] "${task.taskContent}" ƒë√£ b·ªã x√≥a kh·ªèi danh s√°ch.`);
  } catch (error: any) {
    console.error('Error deleting task:', error.response?.data || error.message);
    if (error.response?.status === 404) {
      bot.sendMessage(chatId, `‚ùå Kh√¥ng t√¨m th·∫•y task v·ªõi ID ${taskId}.`);
    } else {
      bot.sendMessage(chatId, '‚ùå C√≥ l·ªói x·∫£y ra khi x√≥a c√¥ng vi·ªác.');
    }
  }
});

// API endpoint ƒë·ªÉ scheduler g·ª≠i reminders
app.post('/send-reminder', async (req, res) => {
  try {
    const { chatId, message } = req.body;
    
    await bot.sendMessage(chatId, message);
    res.json({ success: true, message: 'Reminder sent successfully' });
  } catch (error: any) {
    console.error('Error sending reminder:', error.message);
    res.status(500).json({ error: 'Failed to send reminder' });
  }
});

// Health check endpoint
app.get('/health', (req, res) => {
  res.json({ status: 'OK', service: 'Bot Service' });
});

// Handle errors
bot.on('polling_error', (error) => {
  console.error('Telegram polling error:', error);
});

app.listen(PORT, () => {
  console.log(`ü§ñ Bot Service running on port ${PORT}`);
  console.log('üöÄ Telegram bot is ready!');
});