# ==================================================
# Path: E:\HTMLCSS\PROJECT_ONTAP\Project_TodoMate
# Detected tech: docker, javascript, typescript
# ==================================================

## DIRECTORY STRUCTURE
```
Project_TodoMate/
├── services/
│   ├── bot-service/
│   │   ├── src/
│   │   │   └── index.ts
│   │   ├── .dockerignore
│   │   ├── Dockerfile
│   │   ├── package.json
│   │   └── tsconfig.json
│   ├── database-service/
│   │   ├── src/
│   │   │   ├── models/
│   │   │   │   ├── counter.model.ts
│   │   │   │   └── task.model.ts
│   │   │   ├── db.ts
│   │   │   └── index.ts
│   │   ├── .dockerignore
│   │   ├── Dockerfile
│   │   ├── package.json
│   │   └── tsconfig.json
│   ├── nlp-service/
│   │   ├── src/
│   │   │   └── index.ts
│   │   ├── .dockerignore
│   │   ├── Dockerfile
│   │   ├── package.json
│   │   └── tsconfig.json
│   ├── reminder-service/
│   │   ├── src/
│   │   │   └── index.ts
│   │   ├── .dockerignore
│   │   ├── Dockerfile
│   │   ├── package.json
│   │   └── tsconfig.json
│   └── scheduler-service/
│       ├── src/
│       │   └── index.ts
│       ├── .dockerignore
│       ├── Dockerfile
│       ├── package.json
│       └── tsconfig.json
├── .env
└── docker-compose.yml
```

## FILE CONTENTS

### services\bot-service\src\index.ts
```ts
// ===== services/bot-service/src/index.ts =====
import TelegramBot from 'node-telegram-bot-api';
import express from 'express';
import axios from 'axios';
import dotenv from 'dotenv';
import { format } from 'date-fns';

dotenv.config();

const app = express();
app.use(express.json());

const PORT = process.env.BOT_SERVICE_PORT || 3001;
const TELEGRAM_BOT_TOKEN = process.env.TELEGRAM_BOT_TOKEN!;
const NLP_SERVICE_URL = process.env.NLP_SERVICE_URL || 'http://nlp-service:3002';
const REMINDER_SERVICE_URL = process.env.REMINDER_SERVICE_URL || 'http://reminder-service:3003';

// Khởi tạo bot
const bot = new TelegramBot(TELEGRAM_BOT_TOKEN, { polling: true });

// Command parser
const parseCommand = (text: string) => {
  const parts = text.split(' ');
  const command = parts[0].toLowerCase();
  const args = parts.slice(1);
  return { command, args, fullText: text };
};

// Format task display
const formatTask = (task: any) => {
  const formattedDate = format(new Date(task.dueDate), 'HH:mm dd-MM-yyyy');
  const statusIcon = task.status === 'completed' ? '✅' : '⏳';
  const overdueIcon = new Date(task.dueDate) < new Date() && task.status === 'pending' ? '🔴' : '';
  
  return `[${task.taskId}] 📝 ${task.taskContent}\n📅 ${formattedDate}\n${statusIcon} Trạng thái: ${task.status === 'pending' ? 'Pending' : 'Done'} ${overdueIcon}`;
};

// Format task list with pagination
const formatTaskList = (data: any, title: string) => {
  if (!data.tasks || data.tasks.length === 0) {
    return `${title}:\n(Không có công việc nào được tìm thấy)`;
  }

  let message = `${title} (Trang ${data.pagination.currentPage}/${data.pagination.totalPages}):\n\n`;
  
  data.tasks.forEach((task: any) => {
    message += formatTask(task) + '\n\n';
  });

  if (data.pagination.totalPages > 1) {
    message += `📄 Trang ${data.pagination.currentPage}/${data.pagination.totalPages} - Tổng: ${data.pagination.total} công việc`;
  }

  return message;
};

// Command handlers
bot.onText(/\/start/, (msg) => {
  const chatId = msg.chat.id;
  const welcomeMessage = `Xin chào 👋! Tôi là TaskReminder Bot.
Tôi sẽ giúp bạn quản lý và nhắc nhở công việc hằng ngày.
👉 Gõ /help để xem danh sách lệnh.`;
  
  bot.sendMessage(chatId, welcomeMessage);
});

bot.onText(/\/help/, (msg) => {
  const chatId = msg.chat.id;
  const helpMessage = `📌 Các lệnh bạn có thể dùng:
/add [nội dung] - Thêm công việc mới bằng ngôn ngữ tự nhiên.
/list [số trang] - Liệt kê tất cả công việc.
/pending [số trang] - Xem công việc chưa hoàn thành.
/done [số trang] - Xem công việc đã hoàn thành.
/overdue [số trang] - Xem công việc quá hạn.
/today - Công việc hôm nay.
/tomorrow - Công việc ngày mai.
/date [DD-MM-YYYY] - Lọc công việc theo ngày cụ thể.
/search [từ khóa] - Tìm công việc.
/update [id] [trường]=[giá trị mới] - Cập nhật công việc.
/complete [id] - Đánh dấu hoàn thành.
/delete [id] - Xóa công việc.`;

  bot.sendMessage(chatId, helpMessage);
});

bot.onText(/\/add (.+)/, async (msg, match) => {
  const chatId = msg.chat.id;
  const userId = msg.from?.id.toString() || '';
  const text = match![1];

  try {
    // Gửi đến NLP service để xử lý
    const nlpResponse = await axios.post(`${NLP_SERVICE_URL}/process`, {
      text,
      refDate: new Date().toISOString()
    });

    const { taskContent, dueDate } = nlpResponse.data;

    // Gửi đến reminder service để tạo task
    const reminderResponse = await axios.post(`${REMINDER_SERVICE_URL}/tasks`, {
      userId,
      chatId: chatId.toString(),
      taskContent,
      dueDate
    });

    const task = reminderResponse.data;
    const formattedDate = format(new Date(dueDate), 'HH:mm dd-MM-yyyy');

    const successMessage = `✅ Đã thêm task mới:
📝 ${taskContent}
📅 Deadline: ${formattedDate}
🔔 Tôi sẽ nhắc bạn trước 30 phút và đúng giờ.
(Task ID: ${task.taskId})`;

    bot.sendMessage(chatId, successMessage);
  } catch (error: any) {
    console.error('Error adding task:', error.response?.data || error.message);
    bot.sendMessage(chatId, '❌ Có lỗi xảy ra khi thêm công việc. Vui lòng thử lại.');
  }
});

bot.onText(/\/list(\s+(\d+))?/, async (msg, match) => {
  const chatId = msg.chat.id;
  const userId = msg.from?.id.toString() || '';
  const page = match?.[2] || '1';

  try {
    const response = await axios.get(`${REMINDER_SERVICE_URL}/tasks/user/${userId}?page=${page}&limit=10`);
    const message = formatTaskList(response.data, '📋 Tất cả công việc');
    bot.sendMessage(chatId, message);
  } catch (error: any) {
    console.error('Error fetching tasks:', error.response?.data || error.message);
    bot.sendMessage(chatId, '❌ Có lỗi xảy ra khi lấy danh sách công việc.');
  }
});

bot.onText(/\/pending(\s+(\d+))?/, async (msg, match) => {
  const chatId = msg.chat.id;
  const userId = msg.from?.id.toString() || '';
  const page = match?.[2] || '1';

  try {
    const response = await axios.get(`${REMINDER_SERVICE_URL}/tasks/user/${userId}?status=pending&page=${page}&limit=10`);
    const message = formatTaskList(response.data, '📋 Công việc chưa hoàn thành');
    bot.sendMessage(chatId, message);
  } catch (error: any) {
    console.error('Error fetching pending tasks:', error.response?.data || error.message);
    bot.sendMessage(chatId, '❌ Có lỗi xảy ra khi lấy danh sách công việc chưa hoàn thành.');
  }
});

bot.onText(/\/done(\s+(\d+))?/, async (msg, match) => {
  const chatId = msg.chat.id;
  const userId = msg.from?.id.toString() || '';
  const page = match?.[2] || '1';

  try {
    const response = await axios.get(`${REMINDER_SERVICE_URL}/tasks/user/${userId}?status=completed&page=${page}&limit=10`);
    const message = formatTaskList(response.data, '📋 Công việc đã hoàn thành');
    bot.sendMessage(chatId, message);
  } catch (error: any) {
    console.error('Error fetching completed tasks:', error.response?.data || error.message);
    bot.sendMessage(chatId, '❌ Có lỗi xảy ra khi lấy danh sách công việc đã hoàn thành.');
  }
});

bot.onText(/\/overdue(\s+(\d+))?/, async (msg, match) => {
  const chatId = msg.chat.id;
  const userId = msg.from?.id.toString() || '';
  const page = match?.[2] || '1';

  try {
    const response = await axios.get(`${REMINDER_SERVICE_URL}/tasks/user/${userId}?filter=overdue&page=${page}&limit=10`);
    const message = formatTaskList(response.data, '📋 Công việc quá hạn');
    bot.sendMessage(chatId, message);
  } catch (error: any) {
    console.error('Error fetching overdue tasks:', error.response?.data || error.message);
    bot.sendMessage(chatId, '❌ Có lỗi xảy ra khi lấy danh sách công việc quá hạn.');
  }
});

bot.onText(/\/today/, async (msg) => {
  const chatId = msg.chat.id;
  const userId = msg.from?.id.toString() || '';

  try {
    const response = await axios.get(`${REMINDER_SERVICE_URL}/tasks/user/${userId}?filter=today`);
    const currentDate = format(new Date(), 'dd-MM-yyyy');
    const message = formatTaskList(response.data, `📅 Công việc hôm nay (${currentDate})`);
    bot.sendMessage(chatId, message);
  } catch (error: any) {
    console.error('Error fetching today tasks:', error.response?.data || error.message);
    bot.sendMessage(chatId, '❌ Có lỗi xảy ra khi lấy công việc hôm nay.');
  }
});

bot.onText(/\/tomorrow/, async (msg) => {
  const chatId = msg.chat.id;
  const userId = msg.from?.id.toString() || '';

  try {
    const response = await axios.get(`${REMINDER_SERVICE_URL}/tasks/user/${userId}?filter=tomorrow`);
    const tomorrowDate = format(new Date(Date.now() + 24 * 60 * 60 * 1000), 'dd-MM-yyyy');
    const message = formatTaskList(response.data, `📅 Công việc ngày mai (${tomorrowDate})`);
    bot.sendMessage(chatId, message);
  } catch (error: any) {
    console.error('Error fetching tomorrow tasks:', error.response?.data || error.message);
    bot.sendMessage(chatId, '❌ Có lỗi xảy ra khi lấy công việc ngày mai.');
  }
});

bot.onText(/\/date\s+(\d{2}-\d{2}-\d{4})/, async (msg, match) => {
  const chatId = msg.chat.id;
  const userId = msg.from?.id.toString() || '';
  const dateStr = match![1];

  try {
    // Convert DD-MM-YYYY to YYYY-MM-DD format for API
    const [day, month, year] = dateStr.split('-');
    const apiDate = `${year}-${month}-${day}`;
    
    const response = await axios.get(`${REMINDER_SERVICE_URL}/tasks/user/${userId}?date=${apiDate}`);
    const message = formatTaskList(response.data, `📅 Công việc ngày ${dateStr}`);
    bot.sendMessage(chatId, message);
  } catch (error: any) {
    console.error('Error fetching tasks by date:', error.response?.data || error.message);
    bot.sendMessage(chatId, '❌ Có lỗi xảy ra khi lấy công việc theo ngày. Định dạng: /date DD-MM-YYYY');
  }
});

bot.onText(/\/search (.+)/, async (msg, match) => {
  const chatId = msg.chat.id;
  const userId = msg.from?.id.toString() || '';
  const keyword = match![1];

  try {
    const response = await axios.get(`${REMINDER_SERVICE_URL}/tasks/user/${userId}?search=${encodeURIComponent(keyword)}`);
    const message = formatTaskList(response.data, `🔍 Kết quả tìm kiếm cho "${keyword}"`);
    bot.sendMessage(chatId, message);
  } catch (error: any) {
    console.error('Error searching tasks:', error.response?.data || error.message);
    bot.sendMessage(chatId, '❌ Có lỗi xảy ra khi tìm kiếm công việc.');
  }
});

bot.onText(/\/update\s+(\d+)\s+(\w+)=(.+)/, async (msg, match) => {
  const chatId = msg.chat.id;
  const userId = msg.from?.id.toString() || '';
  const taskId = match![1];
  const field = match![2];
  const value = match![3];

  try {
    const response = await axios.patch(`${REMINDER_SERVICE_URL}/tasks/${taskId}`, {
      userId,
      field,
      value
    });

    let successMessage = '';
    if (field === 'content') {
      successMessage = `🔄 Task [${taskId}] đã được cập nhật nội dung:\n📝 ${value}`;
    } else if (field === 'deadline') {
      const formattedDate = format(new Date(value), 'HH:mm dd-MM-yyyy');
      successMessage = `🔄 Task [${taskId}] đã được cập nhật deadline:\n📅 ${formattedDate}`;
    }

    bot.sendMessage(chatId, successMessage);
  } catch (error: any) {
    console.error('Error updating task:', error.response?.data || error.message);
    if (error.response?.status === 404) {
      bot.sendMessage(chatId, `❌ Không tìm thấy task với ID ${taskId}.`);
    } else {
      bot.sendMessage(chatId, '❌ Có lỗi xảy ra khi cập nhật công việc.');
    }
  }
});

bot.onText(/\/complete\s+(\d+)/, async (msg, match) => {
  const chatId = msg.chat.id;
  const userId = msg.from?.id.toString() || '';
  const taskId = match![1];

  try {
    const response = await axios.patch(`${REMINDER_SERVICE_URL}/tasks/${taskId}`, {
      userId,
      field: 'status',
      value: 'completed'
    });

    const task = response.data;
    bot.sendMessage(chatId, `🎉 Task [${taskId}] "${task.taskContent}" đã được đánh dấu là DONE.`);
  } catch (error: any) {
    console.error('Error completing task:', error.response?.data || error.message);
    if (error.response?.status === 404) {
      bot.sendMessage(chatId, `❌ Không tìm thấy task với ID ${taskId}.`);
    } else {
      bot.sendMessage(chatId, '❌ Có lỗi xảy ra khi đánh dấu hoàn thành công việc.');
    }
  }
});

bot.onText(/\/delete\s+(\d+)/, async (msg, match) => {
  const chatId = msg.chat.id;
  const userId = msg.from?.id.toString() || '';
  const taskId = match![1];

  try {
    const response = await axios.delete(`${REMINDER_SERVICE_URL}/tasks/${taskId}?userId=${userId}`);
    const task = response.data.task;
    bot.sendMessage(chatId, `🗑️ Task [${taskId}] "${task.taskContent}" đã bị xóa khỏi danh sách.`);
  } catch (error: any) {
    console.error('Error deleting task:', error.response?.data || error.message);
    if (error.response?.status === 404) {
      bot.sendMessage(chatId, `❌ Không tìm thấy task với ID ${taskId}.`);
    } else {
      bot.sendMessage(chatId, '❌ Có lỗi xảy ra khi xóa công việc.');
    }
  }
});

// API endpoint để scheduler gửi reminders
app.post('/send-reminder', async (req, res) => {
  try {
    const { chatId, message } = req.body;
    
    await bot.sendMessage(chatId, message);
    res.json({ success: true, message: 'Reminder sent successfully' });
  } catch (error: any) {
    console.error('Error sending reminder:', error.message);
    res.status(500).json({ error: 'Failed to send reminder' });
  }
});

// Health check endpoint
app.get('/health', (req, res) => {
  res.json({ status: 'OK', service: 'Bot Service' });
});

// Handle errors
bot.on('polling_error', (error) => {
  console.error('Telegram polling error:', error);
});

app.listen(PORT, () => {
  console.log(`🤖 Bot Service running on port ${PORT}`);
  console.log('🚀 Telegram bot is ready!');
});
```

### services\database-service\src\db.ts
```ts
// ===== services/database-service/src/db.ts =====
import mongoose from 'mongoose';

export const connectDatabase = async () => {
  try {
    const mongoUrl = process.env.MONGO_URL;
    if (!mongoUrl) {
      throw new Error('MONGO_URL environment variable is not set');
    }

    await mongoose.connect(mongoUrl);
    console.log('✅ Database connected successfully');
  } catch (error) {
    console.error('❌ Database connection failed:', error);
    process.exit(1);
  }
};

export const disconnectDatabase = async () => {
  try {
    await mongoose.disconnect();
    console.log('🔌 Database disconnected');
  } catch (error) {
    console.error('❌ Database disconnection failed:', error);
  }
};
```

### services\database-service\src\index.ts
```ts
// ===== services/database-service/src/index.ts =====
import express from 'express';
import dotenv from 'dotenv';
import { connectDatabase } from './db';
import { Task, ITask } from './models/task.model';
import { Counter } from './models/counter.model';

dotenv.config();

const app = express();
app.use(express.json());

const PORT = process.env.DATABASE_SERVICE_PORT || 3004;

// Tạo task ID tự tăng cho user
const getNextTaskId = async (userId: string): Promise<number> => {
  const counter = await Counter.findOneAndUpdate(
    { userId },
    { $inc: { taskId: 1 } },
    { upsert: true, new: true }
  );
  return counter.taskId;
};

// API tạo task mới
app.post('/tasks', async (req, res) => {
  try {
    const { userId, chatId, taskContent, dueDate, reminders } = req.body;
    
    const taskId = await getNextTaskId(userId);
    
    const task = new Task({
      taskId,
      userId,
      chatId,
      taskContent,
      dueDate: new Date(dueDate),
      reminders: reminders.map((r: any) => ({
        type: r.type,
        reminderTime: new Date(r.reminderTime),
        sent: false
      }))
    });
    
    await task.save();
    res.status(201).json(task);
  } catch (error) {
    console.error('Error creating task:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// API lấy danh sách tasks với query parameters phức tạp
app.get('/tasks/user/:userId', async (req, res) => {
  try {
    const { userId } = req.params;
    const { 
      status, 
      filter, 
      date, 
      search, 
      page = 1, 
      limit = 10 
    } = req.query;

    let query: any = { userId };
    
    // Filter by status
    if (status) {
      query.status = status;
    }
    
    // Filter by date range
    const now = new Date();
    const today = new Date(now.getFullYear(), now.getMonth(), now.getDate());
    const tomorrow = new Date(today);
    tomorrow.setDate(tomorrow.getDate() + 1);
    
    if (filter === 'today') {
      query.dueDate = {
        $gte: today,
        $lt: tomorrow
      };
    } else if (filter === 'tomorrow') {
      const dayAfterTomorrow = new Date(tomorrow);
      dayAfterTomorrow.setDate(dayAfterTomorrow.getDate() + 1);
      query.dueDate = {
        $gte: tomorrow,
        $lt: dayAfterTomorrow
      };
    } else if (filter === 'overdue') {
      query.dueDate = { $lt: now };
      query.status = 'pending';
    } else if (date) {
      const targetDate = new Date(date as string);
      const nextDay = new Date(targetDate);
      nextDay.setDate(nextDay.getDate() + 1);
      query.dueDate = {
        $gte: targetDate,
        $lt: nextDay
      };
    }
    
    // Search in task content
    if (search) {
      query.taskContent = { $regex: search, $options: 'i' };
    }
    
    const pageNum = parseInt(page as string);
    const limitNum = parseInt(limit as string);
    const skip = (pageNum - 1) * limitNum;
    
    const tasks = await Task.find(query)
      .sort({ dueDate: 1 })
      .skip(skip)
      .limit(limitNum);
    
    const total = await Task.countDocuments(query);
    const totalPages = Math.ceil(total / limitNum);
    
    res.json({
      tasks,
      pagination: {
        currentPage: pageNum,
        totalPages,
        total,
        hasNext: pageNum < totalPages,
        hasPrev: pageNum > 1
      }
    });
  } catch (error) {
    console.error('Error fetching tasks:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// API cập nhật task
app.patch('/tasks/:taskId', async (req, res) => {
  try {
    const { taskId } = req.params;
    const { userId, updates } = req.body;
    
    const task = await Task.findOneAndUpdate(
      { taskId: parseInt(taskId), userId },
      updates,
      { new: true }
    );
    
    if (!task) {
      return res.status(404).json({ error: 'Task not found' });
    }
    
    res.json(task);
  } catch (error) {
    console.error('Error updating task:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// API xóa task
app.delete('/tasks/:taskId', async (req, res) => {
  try {
    const { taskId } = req.params;
    const { userId } = req.query;
    
    const task = await Task.findOneAndDelete({
      taskId: parseInt(taskId),
      userId
    });
    
    if (!task) {
      return res.status(404).json({ error: 'Task not found' });
    }
    
    res.json({ message: 'Task deleted successfully', task });
  } catch (error) {
    console.error('Error deleting task:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// API lấy reminders đã đến hạn
app.get('/tasks/due', async (req, res) => {
  try {
    const now = new Date();
    
    const tasks = await Task.find({
      'reminders.reminderTime': { $lte: now },
      'reminders.sent': false
    });
    
    const dueReminders = [];
    
    for (const task of tasks) {
      for (const reminder of task.reminders) {
        if (reminder.reminderTime <= now && !reminder.sent) {
          dueReminders.push({
            taskId: task.taskId,
            userId: task.userId,
            chatId: task.chatId,
            taskContent: task.taskContent,
            dueDate: task.dueDate,
            reminderType: reminder.type,
            reminderId: reminder._id
          });
        }
      }
    }
    
    res.json(dueReminders);
  } catch (error) {
    console.error('Error fetching due reminders:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// API đánh dấu reminder đã gửi
app.patch('/tasks/reminders/sent', async (req, res) => {
  try {
    const { reminderId } = req.body;
    
    await Task.updateOne(
      { 'reminders._id': reminderId },
      { $set: { 'reminders.$.sent': true } }
    );
    
    res.json({ message: 'Reminder marked as sent' });
  } catch (error) {
    console.error('Error marking reminder as sent:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Start server
connectDatabase().then(() => {
  app.listen(PORT, () => {
    console.log(`🗄️  Database Service running on port ${PORT}`);
  });
});
```

### services\database-service\src\models\counter.model.ts
```ts
// ===== services/database-service/src/models/counter.model.ts =====
import mongoose, { Schema, Document } from 'mongoose';

export interface ICounter extends Document {
  userId: string;
  taskId: number;
}

const CounterSchema = new Schema<ICounter>({
  userId: { type: String, required: true, unique: true },
  taskId: { type: Number, default: 0 }
});

export const Counter = mongoose.model<ICounter>('Counter', CounterSchema, 'counters');
```

### services\database-service\src\models\task.model.ts
```ts
// ===== services/database-service/src/models/task.model.ts =====
import mongoose, { Schema, Document } from "mongoose";

export interface ITask extends Document {
  taskId: number;
  userId: string;
  chatId: string;
  taskContent: string;
  dueDate: Date;
  status: "pending" | "completed";
  reminders: (mongoose.Types.Subdocument & {
    type: "30_minutes" | "exact_time";
    reminderTime: Date;
    sent: boolean;
  })[];
  createdAt: Date;
  updatedAt: Date;
}

const TaskSchema = new Schema<ITask>(
  {
    taskId: { type: Number, required: true },
    userId: { type: String, required: true },
    chatId: { type: String, required: true },
    taskContent: { type: String, required: true },
    dueDate: { type: Date, required: true },
    status: {
      type: String,
      enum: ["pending", "completed"],
      default: "pending",
    },
    reminders: [
      {
        type: {
          type: String,
          enum: ["30_minutes", "exact_time"],
          required: true,
        },
        reminderTime: { type: Date, required: true },
        sent: { type: Boolean, default: false },
      },
    ],
  },
  {
    timestamps: true,
  }
);

// Tạo compound index để tìm kiếm nhanh hơn
TaskSchema.index({ userId: 1, taskId: 1 });
TaskSchema.index({ userId: 1, status: 1 });
TaskSchema.index({ userId: 1, dueDate: 1 });
TaskSchema.index({ "reminders.reminderTime": 1, "reminders.sent": 1 });

export const Task = mongoose.model<ITask>("Task", TaskSchema, "tasks");

```

### services\nlp-service\src\index.ts
```ts
// ===== services/nlp-service/src/index.ts =====
import express from 'express';
import dotenv from 'dotenv';
import * as chrono from 'chrono-node';

dotenv.config();

const app = express();
app.use(express.json());

const PORT = process.env.NLP_SERVICE_PORT || 3002;

// API xử lý ngôn ngữ tự nhiên
app.post('/process', (req, res) => {
  try {
    const { text, refDate } = req.body;
    
    if (!text) {
      return res.status(400).json({ error: 'Text is required' });
    }
    
    const referenceDate = refDate ? new Date(refDate) : new Date();
    
    // Sử dụng chrono-node để parse thời gian
    const parsedResults = chrono.parse(text, referenceDate);
    
    let taskContent = text;
    let dueDate = null;
    
    if (parsedResults.length > 0) {
      const chronoResult = parsedResults[0];
      dueDate = chronoResult.start.date();
      
      // Loại bỏ phần thời gian khỏi nội dung task
      const timeText = chronoResult.text;
      taskContent = text.replace(timeText, '').trim();
      
      // Loại bỏ các từ không cần thiết ở đầu
      taskContent = taskContent
        .replace(/^(nhắc tôi|nhắc|reminder|remind me|hãy nhắc tôi)\s*/i, '')
        .trim();
    } else {
      // Nếu không tìm thấy thời gian, set default là 1 giờ sau
      dueDate = new Date(referenceDate.getTime() + 60 * 60 * 1000);
    }
    
    // Làm sạch nội dung task
    if (!taskContent) {
      taskContent = 'Công việc không có tiêu đề';
    }
    
    res.json({
      taskContent: taskContent.charAt(0).toUpperCase() + taskContent.slice(1),
      dueDate: dueDate.toISOString()
    });
    
  } catch (error) {
    console.error('Error processing text:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Health check endpoint
app.get('/health', (req, res) => {
  res.json({ status: 'OK', service: 'NLP Service' });
});

app.listen(PORT, () => {
  console.log(`🧠 NLP Service running on port ${PORT}`);
});
```

### services\reminder-service\src\index.ts
```ts
// ===== services/reminder-service/src/index.ts =====
import express from 'express';
import axios from 'axios';
import dotenv from 'dotenv';
import { subMinutes } from 'date-fns';

dotenv.config();

const app = express();
app.use(express.json());

const PORT = process.env.REMINDER_SERVICE_PORT || 3003;
const DATABASE_SERVICE_URL = process.env.DATABASE_SERVICE_URL || 'http://database-service:3004';

// API tạo task mới
app.post('/tasks', async (req, res) => {
  try {
    const { userId, chatId, taskContent, dueDate } = req.body;
    
    if (!userId || !chatId || !taskContent || !dueDate) {
      return res.status(400).json({ error: 'Missing required fields' });
    }
    
    const dueDateObj = new Date(dueDate);
    
    // Tạo 2 reminders: 30 phút trước và đúng giờ
    const reminders = [
      {
        type: '30_minutes',
        reminderTime: subMinutes(dueDateObj, 30)
      },
      {
        type: 'exact_time',
        reminderTime: dueDateObj
      }
    ];
    
    // Gửi đến database service
    const response = await axios.post(`${DATABASE_SERVICE_URL}/tasks`, {
      userId,
      chatId,
      taskContent,
      dueDate,
      reminders
    });
    
    res.status(201).json(response.data);
  } catch (error: any) {
    console.error('Error creating task:', error.response?.data || error.message);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// API lấy tasks với filters
app.get('/tasks/user/:userId', async (req, res) => {
  try {
    const { userId } = req.params;
    const queryParams = new URLSearchParams(req.query as Record<string, string>);
    
    const response = await axios.get(`${DATABASE_SERVICE_URL}/tasks/user/${userId}?${queryParams}`);
    res.json(response.data);
  } catch (error: any) {
    console.error('Error fetching tasks:', error.response?.data || error.message);
    res.status(500).json({ error: 'Internal server error' });
  }
});

// API cập nhật task
app.patch('/tasks/:taskId', async (req, res) => {
  try {
    const { taskId } = req.params;
    const { userId, field, value } = req.body;
    
    let updates: any = {};
    
    if (field === 'content') {
      updates.taskContent = value;
    } else if (field === 'deadline') {
      const newDueDate = new Date(value);
      updates.dueDate = newDueDate;
      
      // Cập nhật lại reminders khi thay đổi deadline
      updates.reminders = [
        {
          type: '30_minutes',
          reminderTime: subMinutes(newDueDate, 30),
          sent: false
        },
        {
          type: 'exact_time',
          reminderTime: newDueDate,
          sent: false
        }
      ];
    } else if (field === 'status') {
      updates.status = value;
    }
    
    const response = await axios.patch(`${DATABASE_SERVICE_URL}/tasks/${taskId}`, {
      userId,
      updates
    });
    
    res.json(response.data);
  } catch (error: any) {
    console.error('Error updating task:', error.response?.data || error.message);
    if (error.response?.status === 404) {
      return res.status(404).json({ error: 'Task not found' });
    }
    res.status(500).json({ error: 'Internal server error' });
  }
});

// API xóa task
app.delete('/tasks/:taskId', async (req, res) => {
  try {
    const { taskId } = req.params;
    const { userId } = req.query;
    
    const response = await axios.delete(`${DATABASE_SERVICE_URL}/tasks/${taskId}?userId=${userId}`);
    res.json(response.data);
  } catch (error: any) {
    console.error('Error deleting task:', error.response?.data || error.message);
    if (error.response?.status === 404) {
      return res.status(404).json({ error: 'Task not found' });
    }
    res.status(500).json({ error: 'Internal server error' });
  }
});

// Health check endpoint
app.get('/health', (req, res) => {
  res.json({ status: 'OK', service: 'Reminder Service' });
});

app.listen(PORT, () => {
  console.log(`⏰ Reminder Service running on port ${PORT}`);
});
```

### services\scheduler-service\src\index.ts
```ts
// ===== services/scheduler-service/src/index.ts =====
import express from 'express';
import * as cron from 'node-cron';
import axios from 'axios';
import dotenv from 'dotenv';
import { format } from 'date-fns';

dotenv.config();

const app = express();
app.use(express.json());

const PORT = process.env.SCHEDULER_SERVICE_PORT || 3005;
const DATABASE_SERVICE_URL = process.env.DATABASE_SERVICE_URL || 'http://database-service:3004';
const BOT_SERVICE_URL = process.env.BOT_SERVICE_URL || 'http://bot-service:3001';

// Hàm xử lý gửi reminders
const processReminders = async () => {
  try {
    console.log('🔍 Checking for due reminders...');
    
    // Lấy danh sách reminders đã đến hạn
    const response = await axios.get(`${DATABASE_SERVICE_URL}/tasks/due`);
    const dueReminders = response.data;
    
    if (dueReminders.length === 0) {
      console.log('✅ No due reminders found');
      return;
    }
    
    console.log(`📬 Found ${dueReminders.length} due reminders`);
    
    // Xử lý từng reminder
    for (const reminder of dueReminders) {
      try {
        // Tạo nội dung thông báo
        let message = '';
        const formattedDate = format(new Date(reminder.dueDate), 'HH:mm dd-MM-yyyy');
        
        if (reminder.reminderType === '30_minutes') {
          message = `🔔 Nhắc nhở: Task [${reminder.taskId}]\n📝 ${reminder.taskContent}\n📅 Deadline: ${formattedDate}\n⏰ Còn 30 phút nữa!`;
        } else {
          message = `🔔 Nhắc nhở: Task [${reminder.taskId}]\n📝 ${reminder.taskContent}\n📅 Deadline: ${formattedDate}\n⏰ Đã đến hạn!`;
        }
        
        // Gửi thông báo qua bot service
        await axios.post(`${BOT_SERVICE_URL}/send-reminder`, {
          chatId: reminder.chatId,
          message
        });
        
        // Đánh dấu reminder đã gửi
        await axios.patch(`${DATABASE_SERVICE_URL}/tasks/reminders/sent`, {
          reminderId: reminder.reminderId
        });
        
        console.log(`✅ Sent reminder for task ${reminder.taskId} to chat ${reminder.chatId}`);
      } catch (error: any) {
        console.error(`❌ Failed to process reminder for task ${reminder.taskId}:`, error.response?.data || error.message);
      }
    }
  } catch (error: any) {
    console.error('❌ Error processing reminders:', error.response?.data || error.message);
  }
};

// Khởi chạy cron job - chạy mỗi phút
cron.schedule('* * * * *', async () => {
  await processReminders();
}, {
  timezone: 'Asia/Ho_Chi_Minh'
});

// Health check endpoint
app.get('/health', (req, res) => {
  res.json({ 
    status: 'OK', 
    service: 'Scheduler Service',
    cronStatus: 'Running'
  });
});

// Manual trigger endpoint for testing
app.post('/trigger-reminders', async (req, res) => {
  try {
    await processReminders();
    res.json({ message: 'Reminders processed successfully' });
  } catch (error) {
    console.error('Error triggering reminders:', error);
    res.status(500).json({ error: 'Failed to process reminders' });
  }
});

app.listen(PORT, () => {
  console.log(`⏱️  Scheduler Service running on port ${PORT}`);
  console.log('🔄 Cron job started - checking reminders every minute');
});
```
